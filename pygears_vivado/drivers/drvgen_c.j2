#include "{{module_name}}.h"
#include "xil_io.h"
#include <stdlib.h>


/*
    Autogenerated driver for {{module_name}} module, configuring type:
    {{repr(cmd_type)}}
*/

{% for r in regs -%}
#define {{r['path'].upper()}}_OFFSET ({{"%3s" % r['offset']}})
#define {{r['path'].upper()}}_WIDTH  ({{"%3s" % r['width']}})
{% endfor -%}

#define CMD_WORDS_NUM {{cfg_words_num}}
#define CMD_SIZE (CMD_WORDS_NUM*sizeof(u32))
#define DOUT_WORDS_NUM {{dout_words_num}}
#define DOUT_SIZE (DOUT_WORDS_NUM*sizeof(u32))

#define min(a, b) (((a) < (b)) ? (a) : (b))
#define max(a, b) (((a) > (b)) ? (a) : (b))

int {{module_name}}_init(struct {{module_name}}_cfg* cfg, u32 base_address) {
    int status;
    cfg->dma_cfg.DeviceId = 0;
    cfg->dma_cfg.BaseAddr = base_address;
    cfg->dma_cfg.HasStsCntrlStrm = 0;
    cfg->dma_cfg.HasMm2S = 1;
    cfg->dma_cfg.HasMm2SDRE = 0;
    cfg->dma_cfg.Mm2SDataWidth = 64;
    cfg->dma_cfg.HasS2Mm = 1;
    cfg->dma_cfg.HasS2MmDRE = 0;
    cfg->dma_cfg.S2MmDataWidth = 256;
    cfg->dma_cfg.HasSg = 0;
    cfg->dma_cfg.Mm2sNumChannels = 1;
    cfg->dma_cfg.S2MmNumChannels = 1;
    cfg->dma_cfg.Mm2SBurstSize = 8;
    cfg->dma_cfg.S2MmBurstSize = 2;
    cfg->dma_cfg.MicroDmaMode = 0;
    cfg->dma_cfg.AddrWidth = 32;
    cfg->dma_cfg.SgLengthWidth = 14;

    status = XAxiDma_CfgInitialize(&cfg->dma, &cfg->dma_cfg);
    if (status != XST_SUCCESS) {
        return XST_FAILURE;
    }

    XAxiDma_IntrDisable(&cfg->dma, XAXIDMA_IRQ_ALL_MASK,
              XAXIDMA_DEVICE_TO_DMA);
    XAxiDma_IntrDisable(&cfg->dma, XAXIDMA_IRQ_ALL_MASK,
              XAXIDMA_DMA_TO_DEVICE);

    return XST_SUCCESS;
}

int {{module_name}}_send(struct {{module_name}}_cfg* cfg, const u32* cmd) {
    while (XAxiDma_Busy(&cfg->dma, XAXIDMA_DMA_TO_DEVICE)) {
        /* Wait */
    }

    Xil_DCacheFlushRange((UINTPTR)cfg, CMD_SIZE);
    return XAxiDma_SimpleTransfer(&cfg->dma,(UINTPTR) cmd,
             CMD_SIZE, XAXIDMA_DMA_TO_DEVICE);
}

int {{module_name}}_receive(struct {{module_name}}_cfg* cfg, u32* data) {
    while (XAxiDma_Busy(&cfg->dma, XAXIDMA_DEVICE_TO_DMA)) {
        /* Wait */
    }

		return XAxiDma_SimpleTransfer(&cfg->dma, (UINTPTR) data,
					DOUT_SIZE, XAXIDMA_DEVICE_TO_DMA);
}

u32* {{module_name}}_cmd_new() {
    return malloc(CMD_SIZE);
}

u32* {{module_name}}_dout_new() {
    return malloc(DOUT_SIZE);
}

u32 {{module_name}}_get_word(u32* cmd, u32 width, u32 offset) {
    u32 val         = 0;
    u32 cmd_word    = offset / 32;
    u32 word_offset = offset % 32;
    u32 cur_width   = min(32 - word_offset, width);
    u32 mask        = ((1 << cur_width) - 1) << word_offset;

    val = cmd[cmd_word] >> word_offset;

    // If whole width didn't fit inside current word
    if (cur_width < width)
    {
        cmd_word++;
        mask = (1 << (width - cur_width)) - 1;

        val |= (cmd[cmd_word] & mask) << cur_width;
    }

    return val;
}

void {{module_name}}_get(u32* cmd, void* vptr, u32 offset, u32 width) {
    u32* ptr         = (u32*)vptr;
    u32  word_width  = width;
    u32  word_offset = offset;
    for (int i = 0; i < (width + 31) / 32; ++i)
    {
        ptr[i] = {{module_name}}_get_word(cmd, min(word_width, 32), word_offset);
        word_width -= 32;
        word_offset += 32;
    }
}

void {{module_name}}_set_word(u32* cmd, u32 val, u32 width, u32 offset) {
    u32 cmd_word = offset / 32;
    u32 word_offset = offset % 32;
    u32 cur_width = min(32 - word_offset, width);
    u32 mask = ((1 << cur_width) - 1) << word_offset;

    cmd[cmd_word] &= ~mask;
    cmd[cmd_word] |= val << word_offset;

    // If whole width didn't fit inside current word
    if (cur_width < width) {
        val >>= cur_width;
        cur_width = width - cur_width;
        cmd_word++;
        mask = (1 << cur_width) - 1;

        cmd[cmd_word] &= ~mask;
        cmd[cmd_word] |= val;
    }
}

void {{module_name}}_set(u32* cmd, void* vptr, u32 offset, u32 width) {
    u32* ptr = (u32*) vptr;
    u32 word_width = width;
    u32 word_offset = offset;
    for (int i = 0; i < (width + 31)/32; ++i) {
        {{module_name}}_set_word(cmd, ptr[i], min(word_width, 32), word_offset);
        word_width -= 32;
        word_offset += 32;
    }
}

{% for r in regs -%}
void set_{{module_name}}_{{r['path']}}(u32* cmd, void* vptr) {
  {% if len(r['ctrl']) > 0 %}
    uset_{{module_name}}_{{r['ctrl'][0]['path']}}(cmd, {{r['ctrl'][0]['val']}});
  {% endif %}
    {{module_name}}_set(cmd, vptr, {{r['path'].upper()}}_OFFSET, {{r['path'].upper()}}_WIDTH);
}
  {% if r['width'] <= 32 -%}
void uset_{{module_name}}_{{r['path']}}(u32* cmd, u32 val) {
    set_{{module_name}}_{{r['path']}}(cmd, &val);
}

u32 uget_{{module_name}}_{{r['path']}}(u32* cmd) {
    return {{module_name}}_get_word(cmd, {{r['path'].upper()}}_WIDTH, {{r['path'].upper()}}_OFFSET);
}
  {% endif -%}
{% endfor -%}
