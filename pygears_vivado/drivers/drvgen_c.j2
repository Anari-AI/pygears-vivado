#include "{{module_name}}.h"
#include "xil_io.h"
#include <stdlib.h>


/*
    Autogenerated driver for {{module_name}} module, configuring type:
    {{repr(cmd_type)}}
*/

{% for r in regs -%}
#define {{r['path'].upper()}}_OFFSET ({{"%3s" % r['offset']}})
#define {{r['path'].upper()}}_WIDTH  ({{"%3s" % r['width']}})
{% endfor -%}

#define CMD_WORDS_NUM {{cfg_words_num}}
#define CMD_SIZE (CMD_WORDS_NUM*sizeof(u32))
#define DOUT_WORDS_NUM {{dout_words_num}}
#define DOUT_SIZE (DOUT_WORDS_NUM*sizeof(u32))

#define min(a, b) (((a) < (b)) ? (a) : (b))
#define max(a, b) (((a) > (b)) ? (a) : (b))


{% set has_din = 'din' in dma_ports %}
{% set has_dout = 'dout' in dma_ports %}

int {{module_name}}_init(struct {{module_name}}_cfg* cfg, u32 base_address) {
    int status;
    cfg->dma_cfg.DeviceId = 0;
    cfg->dma_cfg.BaseAddr = base_address;
    cfg->dma_cfg.HasStsCntrlStrm = 0;
    cfg->dma_cfg.HasMm2S = {{ "1" if has_din else "0" }};
{% if has_din %}
    cfg->dma_cfg.HasMm2SDRE = 0;
    cfg->dma_cfg.Mm2SDataWidth = {{dma_ports['din']['width']}};
    cfg->dma_cfg.Mm2sNumChannels = 1;
    cfg->dma_cfg.Mm2SBurstSize = 8;
{% endif %}

    cfg->dma_cfg.HasS2Mm = {{ "1" if has_dout else "0" }};
{% if has_dout %}
    cfg->dma_cfg.HasS2MmDRE = 0;
    cfg->dma_cfg.S2MmDataWidth = {{dma_ports['dout']['width']}};
    cfg->dma_cfg.S2MmNumChannels = 1;
    cfg->dma_cfg.S2MmBurstSize = 2;
{% endif %}

    cfg->dma_cfg.HasSg = 0;
    cfg->dma_cfg.MicroDmaMode = 0;
    cfg->dma_cfg.AddrWidth = 32;
    cfg->dma_cfg.SgLengthWidth = 14;

    status = XAxiDma_CfgInitialize(&cfg->dma, &cfg->dma_cfg);
    if (status != XST_SUCCESS) {
        return XST_FAILURE;
    }

    XAxiDma_IntrDisable(&cfg->dma, XAXIDMA_IRQ_ALL_MASK,
              XAXIDMA_DEVICE_TO_DMA);
    XAxiDma_IntrDisable(&cfg->dma, XAXIDMA_IRQ_ALL_MASK,
              XAXIDMA_DMA_TO_DEVICE);

    return XST_SUCCESS;
}

int {{module_name}}_send(struct {{module_name}}_cfg* cfg, const u32* cmd) {
    while (XAxiDma_Busy(&cfg->dma, XAXIDMA_DMA_TO_DEVICE)) {
        /* Wait */
    }

    Xil_DCacheFlushRange((UINTPTR)cmd, CMD_SIZE);
    return XAxiDma_SimpleTransfer(&cfg->dma,(UINTPTR) cmd,
             CMD_SIZE, XAXIDMA_DMA_TO_DEVICE);
}

int {{module_name}}_receive(struct {{module_name}}_cfg* cfg, u32* data) {
    while (XAxiDma_Busy(&cfg->dma, XAXIDMA_DEVICE_TO_DMA)) {
        /* Wait */
    }

		return XAxiDma_SimpleTransfer(&cfg->dma, (UINTPTR) data,
					DOUT_SIZE, XAXIDMA_DEVICE_TO_DMA);
}

int {{module_name}}_call(struct {{module_name}}_cfg* cfg, u32* cmd, u32* data, u32 max_size) {
	int status;
  int max_len = DOUT_SIZE*max_size;
  Xil_DCacheFlushRange((UINTPTR)cmd, CMD_SIZE);

  status = XAxiDma_SimpleTransfer(&cfg->dma, (UINTPTR) data,
      max_len, XAXIDMA_DEVICE_TO_DMA);

	if (status != XST_SUCCESS) {
		return XST_FAILURE;
	}

  status = XAxiDma_SimpleTransfer(&cfg->dma,(UINTPTR) cmd,
           CMD_SIZE, XAXIDMA_DMA_TO_DEVICE);

	if (status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	while ((XAxiDma_Busy(&cfg->dma,XAXIDMA_DEVICE_TO_DMA)) ||
		(XAxiDma_Busy(&cfg->dma,XAXIDMA_DMA_TO_DEVICE))) {
			/* Wait */
	}

	int length = XAxiDma_ReadReg(cfg->dma.RxBdRing[0].ChanBase, XAXIDMA_BUFFLEN_OFFSET);

  Xil_DCacheInvalidateRange((UINTPTR)data, length);

	return length/DOUT_SIZE;
}

void *aligned_malloc(size_t required_bytes, size_t alignment) {
    void *p1;
    void **p2;
    int offset = alignment - 1 + sizeof(void*);
    p1 = malloc(required_bytes + offset);               // the line you are missing
    p2=(void**)(((size_t)(p1)+offset)&~(alignment-1));  //line 5
    p2[-1]=p1; //line 6
    return p2;
}

void aligned_free( void* p ) {
    void* p1 = ((void**)p)[-1];         // get the pointer to the buffer we allocated
    free( p1 );
}

u32* {{module_name}}_cmd_new(struct {{module_name}}_cfg* cfg) {
    return aligned_malloc(CMD_SIZE, cfg->dma_cfg.Mm2SDataWidth);
}

u32* {{module_name}}_dout_new(struct {{module_name}}_cfg* cfg, u32 size) {
    return aligned_malloc(DOUT_SIZE*size, cfg->dma_cfg.S2MmDataWidth);
}

u32 {{module_name}}_get_word(u32* cmd, u32 width, u32 offset) {
    u32 val         = 0;
    u32 cmd_word    = offset / 32;
    u32 word_offset = offset % 32;
    u32 cur_width   = min(32 - word_offset, width);
    u32 mask        = ((1L << cur_width) - 1) << word_offset;

    val = cmd[cmd_word] >> word_offset;

    // If whole width didn't fit inside current word
    if (cur_width < width)
    {
        cmd_word++;
        mask = (1 << (width - cur_width)) - 1;

        val |= (cmd[cmd_word] & mask) << cur_width;
    }

    return val;
}

void {{module_name}}_get(u32* cmd, void* vptr, u32 offset, u32 width) {
    u32* ptr         = (u32*)vptr;
    u32  word_width  = width;
    u32  word_offset = offset;
    for (int i = 0; i < (width + 31) / 32; ++i)
    {
        ptr[i] = {{module_name}}_get_word(cmd, min(word_width, 32), word_offset);
        word_width -= 32;
        word_offset += 32;
    }
}

void {{module_name}}_set_word(u32* cmd, u32 val, u32 width, u32 offset) {
    u32 cmd_word = offset / 32;
    u32 word_offset = offset % 32;
    u32 cur_width = min(32 - word_offset, width);
    u32 mask = ((1L << cur_width) - 1) << word_offset;

    cmd[cmd_word] &= ~mask;
    cmd[cmd_word] |= val << word_offset;

    // If whole width didn't fit inside current word
    if (cur_width < width) {
        val >>= cur_width;
        cur_width = width - cur_width;
        cmd_word++;
        mask = (1 << cur_width) - 1;

        cmd[cmd_word] &= ~mask;
        cmd[cmd_word] |= val;
    }
}

void {{module_name}}_set(u32* cmd, void* vptr, u32 offset, u32 width) {
    u32* ptr = (u32*) vptr;
    u32 word_width = width;
    u32 word_offset = offset;
    for (int i = 0; i < (width + 31)/32; ++i) {
        {{module_name}}_set_word(cmd, ptr[i], min(word_width, 32), word_offset);
        word_width -= 32;
        word_offset += 32;
    }
}

{% for r in regs -%}
void set_{{module_name}}_{{r['path']}}(u32* cmd, void* vptr) {
  {% if len(r['ctrl']) > 0 %}
    uset_{{module_name}}_{{r['ctrl'][0]['path']}}(cmd, {{r['ctrl'][0]['val']}});
  {% endif %}
    {{module_name}}_set(cmd, vptr, {{r['path'].upper()}}_OFFSET, {{r['path'].upper()}}_WIDTH);
}
  {% if r['width'] <= 32 -%}
void uset_{{module_name}}_{{r['path']}}(u32* cmd, u32 val) {
    set_{{module_name}}_{{r['path']}}(cmd, &val);
}

u32 uget_{{module_name}}_{{r['path']}}(u32* cmd) {
    return {{module_name}}_get_word(cmd, {{r['path'].upper()}}_WIDTH, {{r['path'].upper()}}_OFFSET);
}
  {% endif -%}
{% endfor -%}
